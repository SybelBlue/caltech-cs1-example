submit_to: spec/customer_spec.rb
prompt: |
  Take a look at the pay method of Customer, which is the
  subject of the next set of tests that you will construct.<br /><br />

  System Under Test:
  <pl-code language="ruby">
  <![CDATA[
    class Customer
      attr_accessor :name, :gift_card
      def initialize(name, gift_card=nil)
        @gift_card = gift_card
        @name = name
      end
      def pay(amount)
        if gift_card.withdraw(amount)
          self.notify("payment successful")
        else
          self.notify("purchase cannot be completed")
        end
      end
    end
  ]]>
  </pl-code>

  The new challenge in testing
  #pay is that it calls an instance method of another class
  (GiftCard#withdraw).  In this case we know all about the behavior of
  that method, and it's fairly simple.  But if
  don't know the details of how it works, or even worse if it's
  temporarily broken, we don't want our tests to fail just because
  #withdraw is failing.  So we use test doubles to isolate the
  Customer tests from the behavior of GiftCard.<br /><br />

  If you look at Customer#pay, the only behavior we really care about
  regarding #withdraw is whether it returns a truthy or falsy value,
  since that determines what happens next.  This challenge guides you through
  building a single test case in which we construct a test double for
  a gift card.  The double is an object that has no built-in behaviors,
  so it must be given just enough behavior to be useful
  for this test case: we use allow to say "If the double gets a call
  to withdraw, it should just return true".  Similarly, if #pay is
  working correctly, the result of a successful withdrawal should be a
  call to Customer#notify with a happy message.  Note that in this
  case, Customer#notify hasn't even been implemented!  By saying
  that we expect to receive a call to it with a particular argument, we
  basically "short-circuit" the real method call.  This further isolates
  our test case from other methods, even those in Customer itself. <br /><br />
  
solution: 
  pre: |
    describe Customer do
      it 'buys the item if balance covers payment' do
  lines: |
        @loaded_gift_card = double('gift_card')
        allow(@loaded_gift_card).to receive(?:withdraw?).and_return(true)
        @customer = ?Customer?.new('Student', @fake_gift_card)
        expect(?@customer?).to receive(?:notify?).with("payment successful")
        @customer.?pay?(10)
  post: |+2
      end
    end
mutations:
  var_1:
    customer.rb: |
      8c8
      <     if gift_card.withdraw(amount)
      ---
      >     if gift_card.dont_call_withdraw(amount)
  var_2:
    customer.rb: |
      9c9
      <       self.notify("payment successful")
      ---
      >       self.dont_call_notify("payment successful")
  var_3:
    customer.rb: |
      9c9
      <       self.notify("purchase cannot be completed")
      ---
      >       self.dont_call_notify("purchase cannot be completed")
