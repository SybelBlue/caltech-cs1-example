## RSpec Test Writing Exercise

### System Under Test
A lucky number game is defined in the class below. It assigns a valid, secret number upon construction. The `feeling_lucky` method returns true if the secret number matches the random one generated by the `generate` method.

```ruby
class Lucky

    attr_accessor :secret

    def initialize(secret)
      @secret = secret
      raise ArgumentError if @secret < 0 || @secret > 999
    end

    def feeling_lucky
        generate() == @secret
    end

    def generate    
        rand(1000)
    end
end
```

### Write rspec unit tests
Write RSpec unit tests for the `Lucky.new` constructor and the `feeling_lucky` method. An RSpec reference is given below.


## RSpec Reference Cheatsheet
### Basic RSpec Syntax

RSpec tests are written using the `describe` and `it` methods.

- `describe` is used to group a set of tests together and define a subject.
- `it` is used to define a specific test case.

```ruby
describe "MyClass" do
  it "should be an instance of MyClass" do
    expect(MyClass.new).to be_an_instance_of(MyClass)
  end
end
```

### Expectations

Expectations are used to specify the expected behavior of the code being tested.

```ruby
expect(value).to matcher(expected_value)
expect(value).to_not matcher(expected_value)
```

Some commonly used matchers include:

- `eq` - check if two values are equal
- `be` - check if two objects are the same object
- `be_within` - check if a value is within a certain range
- `raise_error` - check if a certain error is raised

```ruby
expect(4).to eq(4)
expect(obj1).to be(obj2)
expect(3.14).to be_within(0.1).of(3.0)
expect { raise "Error!" }.to raise_error("Error!")
```


### Mocks and Stubs

Mocks and stubs facilitate testing methods in isolation. They are used to simulate certain behavior or values during testing.

```ruby
allow(obj).to receive(:method).and_return(value)
expect(obj).to receive(:method).with(args).and_return(value)
```

